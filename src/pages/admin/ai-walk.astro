---
export const prerender = true;
---

<!doctype html>
<html lang="en-GB">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Unbounded:wght@500;700&family=Fraunces:opsz,wght@9..144,500;9..144,700&family=Manrope:wght@400;500;700&display=swap" rel="stylesheet" />
    <title>AI Walk Creator</title>
    <style>
      :root {
        --bg: #efe3cf;
        --card: #fff8ee;
        --text: #2b1d14;
        --muted: #7c6654;
        --line: #dcc6ac;
        --accent: #be6d37;
        --accent-2: #8a4f27;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Manrope", "Segoe UI", Arial, sans-serif;
        color: var(--text);
        background: linear-gradient(130deg, #f3e7d4 0%, #ecd9be 45%, #e3c9a9 100%);
      }
      .wrap {
        width: min(980px, calc(100% - 2rem));
        margin: 1.2rem auto 2rem;
      }
      .topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.8rem;
        margin-bottom: 1rem;
        flex-wrap: wrap;
      }
      a.button,
      button {
        border: 0;
        border-radius: 999px;
        padding: 0.62rem 1rem;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #fff6ed;
        text-decoration: none;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.01em;
      }
      .ghost {
        background: #fff5e8;
        border: 1px solid #d9b995;
        color: #6f3f20;
      }
      .card {
        background: linear-gradient(180deg, var(--card) 0%, #f6ebdc 100%);
        border: 1px solid var(--line);
        border-radius: 18px;
        padding: 1rem;
        margin-bottom: 0.9rem;
      }
      h1, h2, h3 {
        margin: 0 0 0.55rem;
        font-family: "Fraunces", Georgia, serif;
      }
      p { margin: 0 0 0.7rem; color: var(--muted); }
      .grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.75rem;
      }
      .field { display: grid; gap: 0.35rem; }
      label { font-weight: 700; font-size: 0.9rem; color: #5d4431; }
      input, select, textarea {
        width: 100%;
        border: 1px solid #d7bda0;
        border-radius: 10px;
        padding: 0.58rem 0.68rem;
        font: inherit;
        color: var(--text);
        background: #fffaf2;
      }
      textarea { min-height: 100px; resize: vertical; }
      .q-list { display: grid; gap: 0.65rem; }
      .status {
        padding: 0.7rem 0.75rem;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: #f8ecdc;
        color: #5a3a22;
        font-weight: 700;
      }
      .status.error {
        background: #fff0ea;
        color: #8a3f1d;
        border-color: #e6bfa1;
      }
      .actions {
        display: flex;
        gap: 0.55rem;
        flex-wrap: wrap;
      }
      .step-badge {
        display: inline-block;
        padding: 0.25rem 0.58rem;
        border-radius: 999px;
        background: #f7dfc7;
        color: #8a4f27;
        font-size: 0.72rem;
        font-weight: 800;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
      }
      .hidden { display: none; }
      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 0.6rem;
      }
      .metric {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 0.62rem;
        background: #fff6e9;
      }
      .metric .label {
        display: block;
        color: var(--muted);
        font-size: 0.78rem;
        margin-bottom: 0.22rem;
      }
      .metric .value {
        font-weight: 800;
        color: #5d371d;
      }
      .activity-log {
        margin-top: 0.7rem;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 0.55rem;
        background: #fff6e9;
        color: #5d4431;
        font-size: 0.82rem;
        line-height: 1.35;
        max-height: 220px;
        overflow: auto;
        white-space: pre-wrap;
      }
      @media (max-width: 840px) {
        .grid { grid-template-columns: 1fr; }
        .metrics-grid { grid-template-columns: 1fr 1fr; }
      }
      @media (max-width: 560px) {
        .metrics-grid { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <main class="wrap">
      <div class="topbar">
        <a class="button ghost" href="/admin/">Back to CMS</a>
        <span id="who" class="status">Checking admin session...</span>
      </div>

      <section class="card">
        <span class="step-badge">Step 1</span>
        <h1>Upload GPX And Analyze Route</h1>
        <p>Start by uploading your GPX. We will calculate route metrics before asking for post details.</p>
        <div class="grid">
          <div class="field">
            <label for="gpxFile">GPX file</label>
            <input id="gpxFile" type="file" accept=".gpx,application/gpx+xml,application/xml,text/xml" required />
          </div>
        </div>
        <div class="actions" style="margin-top:0.6rem;">
          <button id="analyzeBtn" type="button">Analyze GPX</button>
        </div>
      </section>

      <section id="metricsSection" class="card hidden">
        <h2>Analyzed Route Data</h2>
        <div id="metricsGrid" class="metrics-grid"></div>
      </section>

      <section id="stepTwoSection" class="hidden">
        <section class="card">
          <span class="step-badge">Step 2</span>
          <h2>Add Post Inputs</h2>
          <p>Now add photos, links, and route reflections to generate drafts.</p>
          <div class="grid">
            <div class="field">
              <label for="postMode">What to create</label>
              <select id="postMode">
                <option value="both">Walk page + Blog post</option>
                <option value="walk">Walk page only</option>
                <option value="blog">Blog post only</option>
              </select>
            </div>
            <div class="field">
              <label for="author">Blog author</label>
              <input id="author" type="text" value="Nick" />
            </div>
            <div class="field">
              <label for="walkTitle">Optional walk title override</label>
              <input id="walkTitle" type="text" placeholder="Leave blank to let AI decide" />
            </div>
            <div class="field">
              <label for="blogTitle">Optional blog title override</label>
              <input id="blogTitle" type="text" placeholder="Leave blank to let AI decide" />
            </div>
            <div class="field">
              <label for="stravaRecord">Strava record URL</label>
              <input id="stravaRecord" type="url" />
            </div>
            <div class="field">
              <label for="stravaFlyby">Strava flyby URL</label>
              <input id="stravaFlyby" type="url" />
            </div>
            <div class="field">
              <label for="images">Photos (1-6)</label>
              <input id="images" type="file" accept="image/jpeg,image/png,image/webp" multiple required />
            </div>
          </div>
        </section>

        <section class="card">
          <h2>Walk Reflection Questions</h2>
          <p>Answer as much as you can. AI uses this as source material for the draft.</p>
          <div id="questions" class="q-list"></div>
        </section>

        <section class="card">
          <div class="field">
            <label for="extraNotes">Extra notes for AI (optional)</label>
            <textarea id="extraNotes" placeholder="Anything else you want reflected in the post"></textarea>
          </div>
          <div class="actions" style="margin-top:0.6rem;">
            <button id="generateBtn" type="button">Generate Draft Post(s)</button>
            <button id="clearBtn" type="button" class="ghost">Clear Answers</button>
          </div>
        </section>
      </section>

      <section class="card">
        <div id="status" class="status">Step 1: Upload and analyze GPX.</div>
        <div id="activityLog" class="activity-log">Activity log initialized.</div>
        <div id="draftLinks" class="actions hidden" style="margin-top:0.7rem;">
          <a id="openWalkDraftBtn" class="button hidden" href="#" target="_blank" rel="noopener noreferrer">Open Walk Draft</a>
          <a id="editWalkDraftBtn" class="button ghost hidden" href="#" target="_blank" rel="noopener noreferrer">Edit Walk Draft</a>
          <button id="publishWalkDraftBtn" class="hidden" type="button">Publish Walk Draft</button>
          <a id="openBlogDraftBtn" class="button hidden" href="#" target="_blank" rel="noopener noreferrer">Open Blog Draft</a>
          <a id="editBlogDraftBtn" class="button ghost hidden" href="#" target="_blank" rel="noopener noreferrer">Edit Blog Draft</a>
          <button id="publishBlogDraftBtn" class="hidden" type="button">Publish Blog Draft</button>
        </div>
      </section>
    </main>

    <script>
      const QUESTION_ITEMS = [
        ["where_walked", "Where did you walk?"],
        ["why_route_today", "Why did you choose this route today?"],
        ["familiar_or_new", "Was it familiar ground or somewhere new?"],
        ["distance_and_gain", "What were the distance and elevation gain?"],
        ["compare_recent", "How did it compare to your recent hikes?"],
        ["weather_trail_conditions", "What were the weather and trail conditions?"],
        ["condition_specifics", "List at least 2 specific condition notes (e.g. wind direction, bog depth, visibility)."],
        ["conditions_impact", "Did the conditions enhance or detract from the experience?"],
        ["energy_levels", "How did your energy levels feel during the walk?"],
        ["pace_comfort", "Did the pace feel comfortable or challenging?"],
        ["route_landmarks", "List at least 3 specific landmarks/waypoints in route order."],
        ["standout_sections", "Were there any standout climbs or sections?"],
        ["kit_layers", "What kit and layers did you wear?"],
        ["layering_fit", "Did your layering system suit the conditions?"],
        ["footwear_match", "Did your footwear match the terrain?"],
        ["gear_lessons", "Were there any gear lessons learned?"],
        ["day_mistake_lesson", "One mistake, near miss, or route decision you would change next time?"],
        ["ember_experience", "How did Ember get on during the walk?"],
        ["ember_lead_offlead", "Where was Ember on lead/off lead and why?"],
        ["ember_triggers", "Any trigger points (livestock, dogs, traffic) and how did you manage them?"],
        ["ember_aftercare", "How did Ember recover after the walk (water, paws, rest)?"],
        ["ember_rhythm", "Did she settle into the rhythm of the hike?"],
        ["before_setting_off", "How did you feel before setting off?"],
        ["during_after_feeling", "How did you feel during and after the walk?"],
        ["emotional_moments", "Did the walk have any emotional or reflective moments?"],
        ["walk_purpose", "Did it feel more like fitness, therapy, adventure or routine?"],
        ["what_it_taught", "What did this walk teach you?"],
        ["what_it_meant", "What did it mean to you?"],
        ["overall_rating", "How would you rate the overall experience?"],
        ["walk_again", "Would you walk this route again?"],
        ["safety_notes", "Any route hazards, navigation issues, or safety notes others should know?"],
        ["parking_toilets", "What were parking and facilities like (toilets, cafes, water)?"],
      ];

      const MAX_IMAGE_COUNT = 6;
      const MAX_IMAGE_BYTES_EACH = 6 * 1024 * 1024;
      const MAX_IMAGE_DIMENSION = 1800;
      const OUTPUT_IMAGE_QUALITY = 0.82;
      const MAX_GPX_UPLOAD_BASE64 = 5_500_000;
      const MAX_GPX_POINTS_UPLOAD = 3500;
      
      const questionsEl = document.getElementById("questions");
      const statusEl = document.getElementById("status");
      const whoEl = document.getElementById("who");
      const stepTwoSection = document.getElementById("stepTwoSection");
      const metricsSection = document.getElementById("metricsSection");
      const metricsGrid = document.getElementById("metricsGrid");
      const gpxInput = document.getElementById("gpxFile");
      const activityLogEl = document.getElementById("activityLog");
      const draftLinksEl = document.getElementById("draftLinks");
      const openWalkDraftBtn = document.getElementById("openWalkDraftBtn");
      const editWalkDraftBtn = document.getElementById("editWalkDraftBtn");
      const publishWalkDraftBtn = document.getElementById("publishWalkDraftBtn");
      const openBlogDraftBtn = document.getElementById("openBlogDraftBtn");
      const editBlogDraftBtn = document.getElementById("editBlogDraftBtn");
      const publishBlogDraftBtn = document.getElementById("publishBlogDraftBtn");

      let analyzedGpx = null;
      let latestCreated = { walkPath: "", blogPath: "", walkPublished: false, blogPublished: false };

      function appendActivity(message) {
        const stamp = new Date().toLocaleTimeString("en-GB", { hour12: false });
        const line = '[' + stamp + '] ' + String(message || '');
        activityLogEl.textContent = (line + '\\n' + (activityLogEl.textContent || '')).trim();
      }

      function setStatus(message, error) {
        statusEl.textContent = message;
        statusEl.classList.toggle("error", Boolean(error));
        appendActivity(message);
      }

      function slugFromContentPath(path) {
        const value = String(path || "").trim();
        const match = value.match(/\/([^/]+)\.md$/);
        return match ? match[1] : "";
      }

      function cmsDraftEditUrl(type, slug) {
        if (!slug) return "#";
        const collection = type === "walk" ? "walks" : "blog";
        return "/admin/#/collections/" + collection + "/entries/" + slug;
      }

      function updateDraftButtons(created) {
        const walkSlug = slugFromContentPath(created?.walkPath);
        const blogSlug = slugFromContentPath(created?.blogPath);
        const hasWalk = Boolean(walkSlug);
        const hasBlog = Boolean(blogSlug);
        const walkLiveUrl = hasWalk ? ("/walks/" + walkSlug + "/") : "#";
        const blogLiveUrl = hasBlog ? ("/blog/" + blogSlug + "/") : "#";

        openWalkDraftBtn.classList.toggle("hidden", !hasWalk);
        editWalkDraftBtn.classList.toggle("hidden", !hasWalk);
        publishWalkDraftBtn.classList.toggle("hidden", !hasWalk);

        openBlogDraftBtn.classList.toggle("hidden", !hasBlog);
        editBlogDraftBtn.classList.toggle("hidden", !hasBlog);
        publishBlogDraftBtn.classList.toggle("hidden", !hasBlog);

        openWalkDraftBtn.href = hasWalk ? (created?.walkPublished ? walkLiveUrl : cmsDraftEditUrl("walk", walkSlug)) : "#";
        openWalkDraftBtn.textContent = created?.walkPublished ? "Open Walk Post" : "Preview Walk Draft";
        editWalkDraftBtn.href = hasWalk ? cmsDraftEditUrl("walk", walkSlug) : "#";

        openBlogDraftBtn.href = hasBlog ? (created?.blogPublished ? blogLiveUrl : cmsDraftEditUrl("blog", blogSlug)) : "#";
        openBlogDraftBtn.textContent = created?.blogPublished ? "Open Blog Post" : "Preview Blog Draft";
        editBlogDraftBtn.href = hasBlog ? cmsDraftEditUrl("blog", blogSlug) : "#";

        draftLinksEl.classList.toggle("hidden", !(hasWalk || hasBlog));
      }

      function renderQuestions() {
        for (const [id, prompt] of QUESTION_ITEMS) {
          const wrap = document.createElement("div");
          wrap.className = "field";
          const label = document.createElement("label");
          label.htmlFor = `q-${id}`;
          label.textContent = prompt;
          const textarea = document.createElement("textarea");
          textarea.id = `q-${id}`;
          textarea.dataset.questionId = id;
          wrap.append(label, textarea);
          questionsEl.appendChild(wrap);
        }
      }

      function readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onerror = () => reject(new Error(`Failed reading file ${file.name}`));
          reader.onload = () => {
            const result = String(reader.result || "");
            const comma = result.indexOf(",");
            resolve(comma >= 0 ? result.slice(comma + 1) : result);
          };
          reader.readAsDataURL(file);
        });
      }

      function loadImageElement(file) {
        return new Promise((resolve, reject) => {
          const url = URL.createObjectURL(file);
          const image = new Image();
          image.onload = () => {
            URL.revokeObjectURL(url);
            resolve(image);
          };
          image.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error(`Failed decoding image ${file.name}`));
          };
          image.src = url;
        });
      }

      function canvasToBase64(canvas, mimeType, quality) {
        return new Promise((resolve, reject) => {
          canvas.toBlob(
            (blob) => {
              if (!blob) {
                reject(new Error("Image optimization failed"));
                return;
              }
              const reader = new FileReader();
              reader.onerror = () => reject(new Error("Failed reading optimized image data"));
              reader.onload = () => {
                const result = String(reader.result || "");
                const comma = result.indexOf(",");
                resolve({
                  contentBase64: comma >= 0 ? result.slice(comma + 1) : result,
                  sizeBytes: blob.size,
                });
              };
              reader.readAsDataURL(blob);
            },
            mimeType,
            quality
          );
        });
      }

      async function optimizeImageForUpload(file) {
        const image = await loadImageElement(file);
        const width = image.naturalWidth || image.width;
        const height = image.naturalHeight || image.height;
        if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
          throw new Error(`Invalid image dimensions for ${file.name}`);
        }

        const scale = Math.min(1, MAX_IMAGE_DIMENSION / Math.max(width, height));
        const targetWidth = Math.max(1, Math.round(width * scale));
        const targetHeight = Math.max(1, Math.round(height * scale));

        const canvas = document.createElement("canvas");
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Unable to process images in this browser");
        }
        ctx.drawImage(image, 0, 0, targetWidth, targetHeight);

        const output = await canvasToBase64(canvas, "image/jpeg", OUTPUT_IMAGE_QUALITY);
        return {
          name: file.name.replace(/\.[^.]+$/, "") + ".jpg",
          mimeType: "image/jpeg",
          contentBase64: output.contentBase64,
          sizeBytes: output.sizeBytes,
        };
      }

      async function loadScriptOnce(src, timeoutMs = 5000) {
        return new Promise((resolve, reject) => {
          const existing = document.querySelector(`script[data-identity-src="${src}"]`);
          if (existing) {
            resolve();
            return;
          }

          const script = document.createElement("script");
          script.src = src;
          script.async = true;
          script.dataset.identitySrc = src;

          const timer = setTimeout(() => {
            script.remove();
            reject(new Error("timeout"));
          }, timeoutMs);

          script.onload = () => {
            clearTimeout(timer);
            resolve();
          };
          script.onerror = () => {
            clearTimeout(timer);
            script.remove();
            reject(new Error("failed"));
          };

          document.head.appendChild(script);
        });
      }

      async function ensureIdentityLoaded() {
        if (window.netlifyIdentity) return;
        const sources = [
          "https://unpkg.com/netlify-identity-widget@1.9.2/build/netlify-identity-widget.js",
          "https://identity.netlify.com/v1/netlify-identity-widget.js",
          "https://cdn.jsdelivr.net/npm/netlify-identity-widget@1.9.2/build/netlify-identity-widget.js",
        ];
        for (const src of sources) {
          try {
            await loadScriptOnce(src);
            if (window.netlifyIdentity) return;
          } catch {}
        }
      }

      async function getIdentityClient(triesLeft = 40) {
        await ensureIdentityLoaded();
        const identity = window.netlifyIdentity;
        if (identity) return identity;
        if (triesLeft <= 0) throw new Error("Netlify Identity is unavailable.");
        await new Promise((resolve) => setTimeout(resolve, 250));
        return getIdentityClient(triesLeft - 1);
      }

      async function requireAdminUser() {
        const identity = await getIdentityClient();
        identity.init();
        const user = identity.currentUser();
        if (!user) {
          identity.open("login");
          throw new Error("Please log in as admin first.");
        }
        const token = await user.jwt();
        whoEl.textContent = user.email || "Admin logged in";
        return { token };
      }

      async function initIdentityStatus() {
        try {
          const identity = await getIdentityClient();
          identity.init();
          const user = identity.currentUser();
          if (user) {
            whoEl.textContent = user.email || "Admin logged in";
            appendActivity("Identity session detected.");
            return;
          }
          whoEl.textContent = "Not logged in";
          appendActivity("No active identity session.");
        } catch (error) {
          whoEl.textContent = "Not logged in";
          setStatus(String(error.message || error), true);
        }
      }

      function parsePoints(xml, tagName) {
        const points = [];
        const blockRegex = new RegExp(`<${tagName}[^>]*lat="([^"]+)"[^>]*lon="([^"]+)"[^>]*>([\\s\\S]*?)<\\/${tagName}>`, "g");
        let match;
        while ((match = blockRegex.exec(xml)) !== null) {
          const lat = Number(match[1]);
          const lon = Number(match[2]);
          const block = match[3] || "";
          const eleMatch = block.match(/<ele>([^<]+)<\/ele>/);
          const timeMatch = block.match(/<time>([^<]+)<\/time>/);
          const ele = eleMatch ? Number(eleMatch[1]) : null;
          const timeMs = timeMatch ? Date.parse(timeMatch[1]) : null;
          if (Number.isFinite(lat) && Number.isFinite(lon)) {
            points.push({
              lat,
              lon,
              ele: Number.isFinite(ele) ? ele : null,
              timeMs: Number.isFinite(timeMs) ? timeMs : null,
            });
          }
        }

        const selfClosingRegex = new RegExp(`<${tagName}[^>]*lat="([^"]+)"[^>]*lon="([^"]+)"[^>]*/>`, "g");
        while ((match = selfClosingRegex.exec(xml)) !== null) {
          const lat = Number(match[1]);
          const lon = Number(match[2]);
          if (Number.isFinite(lat) && Number.isFinite(lon)) {
            points.push({ lat, lon, ele: null, timeMs: null });
          }
        }

        return points;
      }

      function toRad(v) {
        return (v * Math.PI) / 180;
      }

      function haversineMeters(a, b) {
        const R = 6371000;
        const dLat = toRad(b.lat - a.lat);
        const dLon = toRad(b.lon - a.lon);
        const aa =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLon / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(aa), Math.sqrt(1 - aa));
      }

      function formatDuration(totalSeconds) {
        if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) return null;
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${hours}h ${minutes}m ${seconds}s`;
      }

      function parseGpxClient(xml, filename) {
        if (!String(filename || "").toLowerCase().endsWith(".gpx")) {
          throw new Error("Uploaded route file must be a .gpx");
        }

        const points = [...parsePoints(xml, "trkpt"), ...parsePoints(xml, "rtept")];
        if (points.length < 2) {
          throw new Error("GPX did not contain enough route points");
        }

        let meters = 0;
        let ascentMeters = 0;
        for (let i = 1; i < points.length; i += 1) {
          meters += haversineMeters(points[i - 1], points[i]);
          const prevEle = points[i - 1].ele;
          const currEle = points[i].ele;
          if (Number.isFinite(prevEle) && Number.isFinite(currEle) && currEle > prevEle) {
            ascentMeters += currEle - prevEle;
          }
        }

        let minEle = Infinity;
        let maxEle = -Infinity;
        for (const point of points) {
          if (!Number.isFinite(point.ele)) continue;
          if (point.ele < minEle) minEle = point.ele;
          if (point.ele > maxEle) maxEle = point.ele;
        }

        const timeValues = points.map((p) => p.timeMs).filter((v) => Number.isFinite(v));
        const elapsedSeconds = timeValues.length > 1
          ? Math.max(0, Math.round((timeValues[timeValues.length - 1] - timeValues[0]) / 1000))
          : null;

        const distanceMiles = Number((meters / 1609.344).toFixed(2));
        const hours = elapsedSeconds && elapsedSeconds > 0 ? elapsedSeconds / 3600 : null;

        return {
          points: points.length,
          startLat: Number(points[0].lat.toFixed(6)),
          startLng: Number(points[0].lon.toFixed(6)),
          centerLat: Number((points.reduce((s, p) => s + p.lat, 0) / points.length).toFixed(6)),
          centerLng: Number((points.reduce((s, p) => s + p.lon, 0) / points.length).toFixed(6)),
          distanceMiles,
          elevationGainFeet: Math.round(ascentMeters * 3.28084),
          minElevationMeters: Number.isFinite(minEle) ? Math.round(minEle) : null,
          maxElevationMeters: Number.isFinite(maxEle) ? Math.round(maxEle) : null,
          elapsedSeconds,
          elapsedHms: elapsedSeconds ? formatDuration(elapsedSeconds) : null,
          avgMph: hours && distanceMiles > 0 ? Number((distanceMiles / hours).toFixed(2)) : null,
          avgPaceMinPerMile: hours && distanceMiles > 0 ? Number(((hours * 60) / distanceMiles).toFixed(2)) : null,
        };
      }


      function escapeXml(value) {
        return String(value || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&apos;");
      }

      function toBase64Utf8(text) {
        return btoa(unescape(encodeURIComponent(String(text || ""))));
      }

      function buildLightweightGpxXml(points, originalName) {
        const safeName = escapeXml(String(originalName || "walk").replace(/\.[^.]+$/, ""));
        const pointLines = points.map((point) => {
          const lat = Number(point.lat).toFixed(6);
          const lon = Number(point.lon).toFixed(6);
          const ele = Number.isFinite(point.ele) ? `<ele>${Number(point.ele).toFixed(1)}</ele>` : "";
          const time = Number.isFinite(point.timeMs) ? `<time>${new Date(point.timeMs).toISOString()}</time>` : "";
          return `<trkpt lat="${lat}" lon="${lon}">${ele}${time}</trkpt>`;
        });
        return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Walking With Ember" xmlns="http://www.topografix.com/GPX/1/1">
  <trk>
    <name>${safeName}</name>
    <trkseg>
      ${pointLines.join("\n      ")}
    </trkseg>
  </trk>
</gpx>`;
      }

      function buildUploadGpxBase64(gpxText, originalName) {
        const points = parsePoints(gpxText, "trkpt");
        const routePoints = points.length >= 2 ? points : parsePoints(gpxText, "rtept");
        if (routePoints.length < 2) {
          throw new Error("GPX did not contain enough points for upload.");
        }

        const step = Math.max(1, Math.ceil(routePoints.length / MAX_GPX_POINTS_UPLOAD));
        const sampled = [];
        for (let i = 0; i < routePoints.length; i += step) sampled.push(routePoints[i]);
        const last = routePoints[routePoints.length - 1];
        if (sampled[sampled.length - 1] !== last) sampled.push(last);

        const xml = buildLightweightGpxXml(sampled, originalName);
        const contentBase64 = toBase64Utf8(xml);
        return {
          contentBase64,
          originalPoints: routePoints.length,
          pointsUsed: sampled.length,
          wasReduced: sampled.length < routePoints.length,
        };
      }

      function formatMetric(value, suffix = "") {
        if (value === null || value === undefined || value === "") return "N/A";
        return `${value}${suffix}`;
      }

      function renderMetrics(summary) {
        const metrics = [
          ["Track Points", formatMetric(summary.points)],
          ["Distance", formatMetric(summary.distanceMiles, " mi")],
          ["Elevation Gain", formatMetric(summary.elevationGainFeet, " ft")],
          ["Elapsed Time", formatMetric(summary.elapsedHms)],
          ["Average Speed", formatMetric(summary.avgMph, " mph")],
          ["Average Pace", formatMetric(summary.avgPaceMinPerMile, " min/mi")],
          ["Min Elevation", formatMetric(summary.minElevationMeters, " m")],
          ["Max Elevation", formatMetric(summary.maxElevationMeters, " m")],
          ["Map Center", summary.centerLat && summary.centerLng ? `${summary.centerLat}, ${summary.centerLng}` : "N/A"],
        ];

        metricsGrid.innerHTML = "";
        for (const [label, value] of metrics) {
          const card = document.createElement("div");
          card.className = "metric";
          const labelEl = document.createElement("span");
          labelEl.className = "label";
          labelEl.textContent = label;
          const valueEl = document.createElement("span");
          valueEl.className = "value";
          valueEl.textContent = value;
          card.append(labelEl, valueEl);
          metricsGrid.appendChild(card);
        }
      }

      async function analyzeGpx() {
        try {
          setStatus("Checking admin session...");
          await requireAdminUser();

          if (!gpxInput.files || gpxInput.files.length < 1) {
            throw new Error("Please upload a GPX file first.");
          }

          const gpxFile = gpxInput.files[0];
          setStatus("Reading GPX file...");
          const gpxText = await gpxFile.text();

          setStatus("Analyzing route metrics locally...");
          const summary = parseGpxClient(gpxText, gpxFile.name);

          setStatus("Preparing GPX for upload...");
          const uploadGpx = buildUploadGpxBase64(gpxText, gpxFile.name);
          if (uploadGpx.contentBase64.length > MAX_GPX_UPLOAD_BASE64) {
            throw new Error("GPX file is still too large after simplification. Export a shorter/lower-detail GPX and retry.");
          }
          appendActivity(`GPX upload prep: points ${uploadGpx.originalPoints} -> ${uploadGpx.pointsUsed}, b64=${uploadGpx.contentBase64.length}`);

          analyzedGpx = {
            name: gpxFile.name,
            contentBase64: uploadGpx.contentBase64,
            sizeBytes: Math.round((uploadGpx.contentBase64.length * 3) / 4),
            summary,
          };

          renderMetrics(summary);
          metricsSection.classList.remove("hidden");
          stepTwoSection.classList.remove("hidden");
          setStatus("GPX analyzed. Step 2 is now available.");
        } catch (error) {
          analyzedGpx = null;
          metricsSection.classList.add("hidden");
          stepTwoSection.classList.add("hidden");
          setStatus(String(error.message || error), true);
        }
      }

            async function buildGeneratePayload() {
        if (!analyzedGpx) throw new Error("Analyze GPX first before generating posts.");

        const postMode = document.getElementById("postMode").value;
        const author = document.getElementById("author").value.trim();
        const walkTitle = document.getElementById("walkTitle").value.trim();
        const blogTitle = document.getElementById("blogTitle").value.trim();
        const stravaRecord = document.getElementById("stravaRecord").value.trim();
        const stravaFlyby = document.getElementById("stravaFlyby").value.trim();
        const extraNotes = document.getElementById("extraNotes").value.trim();
        const imageInput = document.getElementById("images");

        if (!imageInput.files || imageInput.files.length < 1) throw new Error("Please upload at least one image.");
        if (imageInput.files.length > MAX_IMAGE_COUNT) throw new Error(`Please upload a maximum of ${MAX_IMAGE_COUNT} images.`);

        const answers = {};
        document.querySelectorAll("textarea[data-question-id]").forEach((el) => {
          answers[el.dataset.questionId] = el.value.trim();
        });

        const images = [];
        for (const file of imageInput.files) {
          if (file.size > MAX_IMAGE_BYTES_EACH) {
            throw new Error(`Image ${file.name} is too large. Keep each image under 6MB.`);
          }

          setStatus(`Optimizing image ${images.length + 1} of ${imageInput.files.length}...`);
          const optimized = await optimizeImageForUpload(file);
          images.push({
            name: optimized.name,
            mimeType: optimized.mimeType,
            contentBase64: optimized.contentBase64,
          });
        }

        return {
          postMode,
          author,
          walkTitle,
          blogTitle,
          stravaRecord,
          stravaFlyby,
          extraNotes,
          answers,
          gpxFile: { name: analyzedGpx.name, contentBase64: analyzedGpx.contentBase64 },
          gpxSummary: analyzedGpx.summary,
          images,
        };
      }

      async function callAiTool(token, payload) {
        const action = payload?.action || "unknown";
        const kind = payload?.asset?.kind || "";
        const name = payload?.asset?.name || "";
        const b64Len = payload?.asset?.contentBase64 ? payload.asset.contentBase64.length : 0;
        appendActivity(`API request: ${action}${kind ? ` (${kind})` : ""}${name ? ` ${name}` : ""}${b64Len ? ` b64=${b64Len}` : ""}`);

        const response = await fetch("/.netlify/functions/ai-create-post", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        });

        const raw = await response.text();
        let data = {};
        try { data = raw ? JSON.parse(raw) : {}; } catch {}

        appendActivity(`API response: ${action} status=${response.status} bodyBytes=${raw.length}`);

        if (!response.ok) {
          const detail = data.error || raw || response.statusText || "Unknown error";
          const compactDetail = String(detail).replace(/\s+/g, " ").trim() || "<empty>";
          appendActivity(`API error: ${action} ${compactDetail}`);
          throw new Error(`Request failed (${response.status}): ${compactDetail}`);
        }

        return data;
      }

      async function publishDraft(contentPath, label) {
        if (!contentPath) throw new Error("No draft path available to publish.");
        setStatus("Publishing " + label + " draft...");
        const { token } = await requireAdminUser();
        const result = await callAiTool(token, {
          action: "publish_draft",
          contentPath,
        });
        setStatus(label + " draft published live.");
        appendActivity("Publish commit: " + (result.commit || "(no commit url returned)"));
      }

      async function generate() {
        try {
          latestCreated = { walkPath: "", blogPath: "", walkPublished: false, blogPublished: false };
          draftLinksEl.classList.add("hidden");
          setStatus("Checking admin session...");
          const { token } = await requireAdminUser();

          setStatus("Preparing files and answers...");
          const payload = await buildGeneratePayload();

          setStatus("Uploading GPX asset...");
          const gpxUpload = await callAiTool(token, {
            action: "upload_asset",
            asset: {
              kind: "gpx",
              name: payload.gpxFile.name,
              contentBase64: payload.gpxFile.contentBase64,
            },
          });

          const imageAssets = [];
          for (let i = 0; i < payload.images.length; i += 1) {
            setStatus(`Uploading image ${i + 1} of ${payload.images.length}...`);
            const upload = await callAiTool(token, {
              action: "upload_asset",
              asset: {
                kind: "image",
                name: payload.images[i].name,
                mimeType: payload.images[i].mimeType,
                contentBase64: payload.images[i].contentBase64,
              },
            });
            imageAssets.push(upload.asset);
          }

          setStatus("Generating content and committing files. This can take 30-90 seconds...");
          const data = await callAiTool(token, {
            action: "generate_post",
            postMode: payload.postMode,
            author: payload.author,
            walkTitle: payload.walkTitle,
            blogTitle: payload.blogTitle,
            stravaRecord: payload.stravaRecord,
            stravaFlyby: payload.stravaFlyby,
            extraNotes: payload.extraNotes,
            answers: payload.answers,
            gpxSummary: payload.gpxSummary,
            gpxAsset: gpxUpload.asset,
            imageAssets,
          });

          const created = data.created || {};
          latestCreated = {
            walkPath: created.walkPath || "",
            blogPath: created.blogPath || "",
            walkPublished: false,
            blogPublished: false,
          };
          updateDraftButtons(created);
          const lines = ["Draft generation completed."];
          if (created.walkPath) lines.push(`Walk: ${created.walkPath}`);
          if (created.blogPath) lines.push(`Blog: ${created.blogPath}`);
          if (created.gpxPath) lines.push(`GPX: ${created.gpxPath}`);
          setStatus(lines.join(" "));
        } catch (error) {
          draftLinksEl.classList.add("hidden");
          setStatus(String(error.message || error), true);
        }
      }

      function clearAnswers() {
        document.querySelectorAll("textarea[data-question-id], #extraNotes").forEach((el) => {
          el.value = "";
        });
        setStatus("Answers cleared.");
      }

      gpxInput.addEventListener("change", () => {
        analyzedGpx = null;
        metricsSection.classList.add("hidden");
        stepTwoSection.classList.add("hidden");
      });

      document.getElementById("analyzeBtn").addEventListener("click", analyzeGpx);
      document.getElementById("generateBtn").addEventListener("click", generate);
      document.getElementById("clearBtn").addEventListener("click", clearAnswers);
      publishWalkDraftBtn.addEventListener("click", async () => {
        try {
          await publishDraft(latestCreated.walkPath, "Walk");
          publishWalkDraftBtn.classList.add("hidden");
          latestCreated.walkPublished = true;
          updateDraftButtons(latestCreated);
        } catch (error) {
          setStatus(String(error.message || error), true);
        }
      });
      publishBlogDraftBtn.addEventListener("click", async () => {
        try {
          await publishDraft(latestCreated.blogPath, "Blog");
          publishBlogDraftBtn.classList.add("hidden");
          latestCreated.blogPublished = true;
          updateDraftButtons(latestCreated);
        } catch (error) {
          setStatus(String(error.message || error), true);
        }
      });

      renderQuestions();
      appendActivity("AI Walk page ready.");
      initIdentityStatus();
    </script>
  </body>
</html>









